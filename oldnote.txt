  // const getMessagesByFileId = useCallback(async (fileId: Id<"files">) => {
  //   setIsLoading(true);
  //   try {
  //     const response = await convex.query(api.messages.getMessagesByFileId, {
  //       fileId,
  //     });
  //     if (response.success === false) {
  //       toast.error("An unexpected error occurred");
  //     }
  //     if (response.data) setMessages(response.data);
  //   } catch (error) {
  //     toast.error("An unexpected error occurred");
  //     setMessages([]);
  //   } finally {
  //     setIsLoading(false);
  //   }
  // }, []);



 // if (!messageId) {
      //   toast.error("Failed to send message");
      //   return;
      // }
      // updateMessages({
      //   ...newMsg,
      //   _id: messageId,
      //   createdAt: Date.now(),
      // });



//stream message
export const getAIMessageResponse = action({
  args: {
    prompt: v.string(),
    userId: v.string(),
    fileId: v.id("files"),
  },
  handler: async (ctx, { prompt, userId, fileId }) => {
    try {
      // Create an initial message in the database
      const messageId = await ctx.runMutation(api.messages.createMessage, {
        userId,
        fileId,
        text: "", // Start with an empty body
        role: Role.AI,
      });
      const stream = await chatSession.sendMessageStream({ message: prompt });
      let body = "";

      for await (const chunk of stream) {
        if (chunk?.text) {
          body += chunk.text;
          // Update the message in the database with the partial response
          await ctx.runMutation(api.messages.updateMessage, {
            messageId,
            text: body,
          });
        }
      }

      return body;
    } catch (error) {
      console.error("Chat error:", error);
      throw new Error("Failed to generate chat response");
    }
  },
});      